# VF-TERRAIN — Terrain System

**Version:** 1.0  
**Date:** 20 February 2026  
**Status:** Active  
**Purpose:** Chunked infinite terrain generation, noise system, height calculation, altitude biomes, ground material shader, normal computation, and procedural textures.  
**Dependencies:** VF-CONFIG, VF-ARCH  

---

## 1. Chunked Infinite Terrain

The world is divided into square chunks, each 32m × 32m. Only chunks within a load radius around the player are active.

| Parameter | Value |
|-----------|-------|
| `CHUNK_SIZE` | 32 meters |
| `CHUNK_SEGMENTS` | 31 (32×32 vertex grid = 31×31 quads ≈ 2k triangles) |
| `LOAD_RADIUS` | 5 chunks in each direction |
| `UNLOAD_RADIUS` | 7 chunks (recycled beyond this) |
| `MAX_CHUNKS_PER_FRAME` | 2 (staggered loading) |

When the player enters a new chunk, the system:
1. MUST determine which chunks should be active (Manhattan distance ≤ LOAD_RADIUS)
2. MUST recycle chunks beyond UNLOAD_RADIUS into a pool
3. MUST queue missing chunks sorted by distance (closest first)
4. MUST process at most MAX_CHUNKS_PER_FRAME queued chunks per frame

**Chunk recycling:** Geometry buffers MUST be reused, not destroyed. The pool caps at (LOAD_RADIUS × 2 + 1)² entries.

**Why staggered loading**: Creating a chunk involves thousands of noise evaluations (terrain height for each vertex + tree/vegetation placement). Doing this for multiple chunks in one frame causes visible frame hitches. Limiting to 2 per frame keeps the per-frame cost predictable. The player rarely notices because fog hides unloaded areas.

**Why recycle, not destroy**: In garbage-collected languages (JavaScript), destroying objects creates work for the garbage collector, which can cause unpredictable frame-time spikes. Pooling avoids this entirely.

## 2. Noise System

The terrain uses **13 independent simplex noise instances**, each seeded from a deterministic PRNG (mulberry32) with offsets from a base seed (TERRAIN_SEED = 42):

| Instance | Seed Offset | Purpose |
|----------|-------------|---------|
| noise2D | +0 | Base terrain height |
| treeNoise2D | +1 | Tree density |
| vegNoise2D | +2 | Vegetation density |
| jitterNoise2D | +3 | Placement offsets |
| dirtNoise2D | +4 | Dirt patches |
| rockNoise2D | +5 | Rock placement |
| streamNoise2D | +6 | Stream channels |
| warpNoise2D | +7 | Stream domain warping |
| collectibleNoise2D | +8 | Collectible placement |
| mountainNoise2D | +9 | Mountain ridges |
| mountainWarpNoise2D | +10 | Mountain domain warping |
| mountainDetailNoise2D | +11 | Mountain detail/amplitude |
| logNoise2D | +12 | Fallen log placement |

All 13 instances MUST use the same simplex noise implementation. Each instance MUST be seeded with `TERRAIN_SEED + offset` where offset is the value in the table above.

### Simplex Noise Reference

For implementors who need to match the noise output exactly: the reference uses a standard 2D simplex noise implementation with the following characteristics:

- **Gradient table**: 12 gradient vectors (standard 2D simplex set)
- **Permutation table**: 256-entry table generated by `mulberry32` PRNG
- **Output range**: approximately [-1, 1]
- **Skew factor**: `F2 = 0.5 × (√3 - 1)` ≈ 0.3660254
- **Unskew factor**: `G2 = (3 - √3) / 6` ≈ 0.2113249

The `mulberry32` PRNG: given seed `s`, each call computes:
```
s = (s + 0x6D2B79F5) & 0xFFFFFFFF
t = (s ^ (s >>> 15)) × (s | 1)
t ^= t + (t ^ (t >>> 7)) × (t | 61)
return ((t ^ (t >>> 14)) >>> 0) / 4294967296
```

## 3. Height Calculation

The terrain height at any world coordinate (x, z) MUST be computed by combining three systems:

### 3.1 Base Terrain (Fractal Brownian Motion)

```
baseHeight = fBm(x, z, scale=0.008, octaves=4, persistence=0.45, lacunarity=2.2) × 8.0
```

The `fBm` function MUST layer 4 octaves of simplex noise, each at 2.2× the frequency and 0.45× the amplitude of the previous. The result MUST be normalised to [-1, 1] then scaled by TERRAIN_HEIGHT (8m).

### 3.2 Stream Channels (Domain-Warped Ridge Noise)

Streams are carved using **ridge noise** — the inverse of the absolute value of noise, which creates ridges along zero-crossings:

```
warpX = warpNoise2D(x × 0.006, z × 0.006) × 22
warpZ = warpNoise2D(x × 0.006 + 100, z × 0.006 + 100) × 22

raw = streamNoise2D((x + warpX) × 0.009, (z + warpZ) × 0.009)
ridge = 1 - |raw|
channel = ridge ^ 2      // STREAM_SHARPNESS = 2

normalizedH = (baseHeight / 8 + 1) × 0.5    // 0..1
carveMask = max(0, 1 - normalizedH × 0.8)

streamH = baseHeight - channel × 6.0 × carveMask
```

**Why domain warping**: Without warping, stream channels follow the zero-crossings of raw simplex noise, which produces relatively straight parallel bands. Adding a noise-based coordinate offset before sampling makes the channels meander and curve naturally — like real streams. The warp amount (22) is tuned to produce gentle bends without creating implausible sharp turns.

**Why the carve mask**: Without masking, streams carve deep channels even through mountain peaks. The carve mask reduces stream depth on high terrain, preserving mountain summits while allowing streams to flow through valleys.

### 3.3 Mountain Chains (Additive Ridge Noise)

Mountains use the **inverse** technique of streams — ridge noise pushes terrain **up** instead of down:

```
mwx = mountainWarpNoise2D(x × 0.004, z × 0.004) × 35
mwz = mountainWarpNoise2D(x × 0.004 + 200, z × 0.004 + 200) × 35

mRaw = mountainNoise2D((x + mwx) × 0.003, (z + mwz) × 0.003)
mRidge = 1 - mRaw²           // smooth parabolic peak (not |mRaw|)
mChannel = mRidge ^ 1.0      // MOUNTAIN_SHARPNESS = 1.0

mDetail = mountainDetailNoise2D((x + mwx) × 0.0075, (z + mwz) × 0.0075)
mBlended = mChannel × (0.7 + mDetail × 0.3)

ampMod = mountainDetailNoise2D(x × 0.0012, z × 0.0012) × 0.4 + 0.6

mMask = max(0, mBlended - 0.25) / (1 - 0.25)   // threshold at 0.25

spawnFade = clamp((distance_from_origin - 60) / 40, 0, 1)  // fade in 60-100m from (0,0)

foothillNoise = mountainDetailNoise2D(x × 0.008, z × 0.008)
foothillBase = foothillNoise × 0.5 + 0.5
foothillProximity = min(1, mBlended × 2.5)
foothillH = foothillBase × foothillProximity × 6.0

valleyDip = foothillProximity × (1 - mMask) × 5.0

finalHeight = streamH + (mMask × ampMod × 45 + foothillH - valleyDip) × spawnFade
```

> ⚠️ **Gotcha: Parabolic vs Absolute Value Peaks.** The mountain ridge function MUST use `1 - raw²` for smooth parabolic peaks. Using `1 - |raw|` creates knife-edge ridges. This is a critical visual difference — knife edges look artificial.

> ⚠️ **Gotcha: Spawn Suppression.** Mountains MUST fade in 60–100m from the origin so the player always starts in a forest clearing, not buried in a mountainside.

## 4. Altitude Biomes

The ground shader MUST compute colour based on height with ragged zone boundaries (noise-displaced thresholds):

| Zone | Height Start | Ground Colour | Vegetation |
|------|-------------|---------------|------------|
| Forest | < 10m | Green gradient (low→mid→high) | Full trees, grass, ferns, flowers |
| Subalpine | 10m | Dark forest green (0.15, 0.28, 0.08) | Trees present but only pines, grass thinning |
| Treeline | 16m | Tan/olive tussock (0.55, 0.50, 0.30) | Trees shrink to 30% scale, then vanish; no ferns |
| Alpine | 20m | Grey-brown rock (0.45, 0.42, 0.38) | No trees, no vegetation; increased rock density |
| Snow | 24m | Bright white (1.4, 1.42, 1.5) | Nothing; values >1.0 create emissive bloom |

Zone boundaries MUST be displaced by per-pixel value noise (± ~4m) for ragged, natural transitions. Snow MUST only accumulate on flat surfaces — steep slopes MUST show rock (controlled by `smoothstep(0.6, 0.85, worldNormal.y)`).

## 5. Ground Material

The ground MUST use a single shared `MeshLambertMaterial` with extensive `onBeforeCompile` shader injection:

- **Per-pixel terrain colouring** from height (no vertex-colour banding)
- **Tree density attribute** drives dirt-under-trees patches
- **Shore transitions**: underwater terrain → foam → wet sand → dry sand
- **Dynamic waterline** follows wave height function
- **Weather wetness**: darkens and cool-shifts terrain during rain (uniform `uWetness`, hysteresis: wets in ~2 min, dries in ~4 min)
- **Three procedural textures** (grass, sand, dirt) applied as detail overlays with anti-tiling dual-scale blending
- **Shadow suppression** near/below water to prevent underwater shadow artifacts

### 5.1 Ground Material Shader — Full Algorithm

The ground shader is the most complex piece of rendering logic. Here is the complete per-pixel algorithm:

```
// Inputs available in fragment shader:
//   vWorldPos    — world position from vertex shader
//   vNormal      — world-space normal
//   vTreeDensity — per-vertex tree density (0 = open, 1 = dense forest)
//   uWaterLevel  — -3.5
//   uShoreLevel  — -2.8
//   uWetness     — 0..1 (weather-driven)
//   uTime        — elapsed seconds

// 1. Compute base altitude colour
height = vWorldPos.y
noise = valueNoise(vWorldPos.xz × 0.15)  // for ragged zone edges

// Low terrain gradient (3 greens based on height)
lowColor  = (0.25, 0.45, 0.12)   // valley green
midColor  = (0.22, 0.42, 0.10)   // mid green  
highColor = (0.18, 0.38, 0.08)   // ridge green
baseGreen = mix(lowColor, midColor, smoothstep(-2, 3, height))
baseGreen = mix(baseGreen, highColor, smoothstep(3, 8, height))

// Altitude zone transitions (noise-displaced)
subalpineColor = (0.15, 0.28, 0.08)  // dark forest
treelineColor  = (0.55, 0.50, 0.30)  // tan tussock
alpineColor    = (0.45, 0.42, 0.38)  // grey-brown rock
snowColor      = (1.4, 1.42, 1.5)    // bright emissive white

zoneNoise = noise × 4.0  // ±4m displacement
color = baseGreen
color = mix(color, subalpineColor, smoothstep(10+zoneNoise-2, 10+zoneNoise+2, height))
color = mix(color, treelineColor,  smoothstep(16+zoneNoise-2, 16+zoneNoise+2, height))
color = mix(color, alpineColor,    smoothstep(20+zoneNoise-2, 20+zoneNoise+2, height))

// Snow only on flat surfaces
slopeFactor = smoothstep(0.6, 0.85, vNormal.y)
color = mix(color, snowColor, smoothstep(24+zoneNoise-2, 24+zoneNoise+2, height) × slopeFactor)

// 2. Dirt patches under trees
dirtNoise = dirtNoise2D(vWorldPos.xz)
dirtColor = (0.35, 0.25, 0.12)
dirtMask = smoothstep(0.3, 0.7, vTreeDensity) × smoothstep(0.2, 0.5, dirtNoise)
color = mix(color, dirtColor, dirtMask × 0.6)

// 3. Shore transition
shoreBlend = smoothstep(uShoreLevel, uShoreLevel + 1.5, height)  // 0 at shore, 1 above
if height < uShoreLevel + 1.5:
    // Blend toward sand colour
    sandColor = (0.85, 0.75, 0.55)
    color = mix(sandColor, color, shoreBlend)

// 4. Underwater terrain
if height < uWaterLevel:
    // Darken toward water colour, suppress shadows
    waterBlend = smoothstep(uWaterLevel, uWaterLevel - 2.0, height)
    color = mix(color, (0.05, 0.15, 0.28), waterBlend × 0.7)

// 5. Weather wetness
if uWetness > 0:
    wetColor = color × 0.6  // darken
    wetColor = mix(wetColor, wetColor × (0.85, 0.95, 1.1), 0.3)  // cool-shift
    color = mix(color, wetColor, uWetness)

// 6. Texture detail overlay
// Two-scale anti-tiling: sample texture at 2 different scales, blend
grassTex = texture2D(grassMap, vWorldPos.xz × 0.5) × 0.7 
         + texture2D(grassMap, vWorldPos.xz × 0.13) × 0.3
// Mix in based on surface type (grass/sand/dirt zones)

// Final output
gl_FragColor = vec4(color, 1.0)
// (Lambert lighting applied by Three.js material system)
```

## 6. Normal Computation

Normals MUST be computed from the continuous heightmap using central finite differences:

```
nx = height(x-step, z) - height(x+step, z)
ny = 2 × step
nz = height(x, z-step) - height(x, z+step)
normal = normalize(nx, ny, nz)
```

Interior vertices SHOULD use cached heights; boundary vertices MUST call `getTerrainHeight()` for seamless cross-chunk normals.

> ⚠️ **Gotcha: Chunk boundary normals.** If you compute normals using only vertices within the chunk, you'll get visible lighting seams at chunk edges — the normals at boundary vertices will be computed from only one side of the surface. The fix is to sample the continuous height function for neighbours that fall outside the chunk.

## 7. Procedural Ground Textures

Three 256×256 canvas textures MUST be generated at startup. All textures MUST use **wrap-around drawing** (each element drawn at position + all 8 neighbouring tile copies) for seamless tiling.

**Why wrap-around drawing**: Any element that crosses a tile edge must also appear on the opposite edge. By drawing each element at 9 positions (the actual position plus 8 copies offset by ±width, ±height), elements that extend past one edge seamlessly continue from the opposite edge. This is computationally wasteful (9× the draw calls) but only runs once at startup.

### 7.1 Grass Texture (256×256)
```
1. Fill with neutral grey-green base (120, 130, 110)
2. Draw 600 grass blade strokes:
   - Random position across tile
   - Random lean angle (-30° to 30°)
   - Height 8-25px, width 1-2px
   - Colour: green with brightness variation (40-90, 100-170, 20-60)
   - Slight transparency (alpha 0.4-0.8) for depth layering
3. Draw 200 soil speckles:
   - Small circles (radius 1-3px)
   - Brown earth colour with variation
4. Draw 30 pebble ellipses:
   - Larger ovals (3-6px)
   - Grey-brown with slight shadow underneath
```

### 7.2 Sand Texture (256×256)
```
1. Fill with warm sandy base (190, 180, 150)
2. Draw 1500 fine grain dots (1px each, subtle colour variation)
3. Draw 40 pebble ellipses (2-4px, darker brown/grey)
4. Draw 15 shell fragments:
   - Small curved arcs (5-10px)
   - White/cream with pink or tan tint
5. Draw 25 ripple lines:
   - Shallow sine curves across the tile
   - Very subtle (alpha 0.1-0.2)
   - Slightly lighter or darker than base
```

### 7.3 Dirt Texture (256×256)
```
1. Fill with earthy brown base (140, 110, 75)
2. Draw 300 soil clumps:
   - Irregular circles (2-5px)
   - Darker brown with variation
3. Draw 50 stones:
   - Larger irregular shapes (4-8px)
   - Grey-brown, some with lighter highlight
4. Draw 20 root/twig traces:
   - Thin curved lines (15-30px length)
   - Dark brown, alpha 0.3-0.5
5. Draw 800 fine speckles:
   - 1px dots scattered throughout
   - Mixed light and dark for depth
```

### 7.4 Anti-Tiling in the Shader

Even with seamless textures, tiling is visible at certain view distances. The shader MUST use **dual-scale blending** to break up tiling patterns:

```
primaryUV = worldPos.xz × textureRepeat
secondaryUV = worldPos.xz × textureRepeat × 1.7 + offset
secondaryUV = rotate(secondaryUV, 0.5 radians)

colour = mix(sample(primaryUV), sample(secondaryUV), 0.35)
```

The secondary sample MUST use a different scale (1.7×), a constant offset, and a rotation (0.5 rad ≈ 29°). The blend ratio MUST be 35% secondary.
